<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 2>.外链式 -->
    <script src="../js/login.js">
      // ！！！此处不能再写js代码：无效！！！
    </script>
</head>
<body>
    <!-- 2、js的书写位置 -->
    <!-- 1>.内嵌式：可以写在页面的任何位置（推荐写在html标签最后） -->
    <!-- html5中默认type = "text/javascript"：可以省略 -->
    <script>
        /**
         * 1、js概述
         * 1>.概念：js是一款运行在客户端的网页编程语言
         * 2>.组成部分：ECMAScript(js标准：语法规范) + DOM(文档对象模型：通过js操作网页元素) + BOM(浏览器对象模型：通过api操作浏览器)
         * 3>.特点：简单易用、解析执行（相对于编译执行：js代码不需要编译成可执行文件，直接通过js引擎执行代码）、基于对象
         * 4>.作用：页面特效（pc端的网页特效）、移动端、异步网络交互、服务端开发nodejs
         * 5>.注意：js和java没有关系、js标准：ECMAScript标准（2015年6月发布ES6/ECMAScript-6）
         */
         // 2003年之前 js只能制作弹窗、漂浮广告
         // 2004年 引入Ajax js可以制作应用
         // 2010年 h5引入Canvas js可以开发游戏
         // 2011年 引入Node.js js可以开发服务端

         // 3、js的执行原理：html页面中出现script标签（无论是内嵌式还是外链式）都会让页面的下载和渲染暂停等待脚本的解析和执行，脚本执行完毕以后页面才会继续下载和渲染
         // >>推荐将js代码写在‘html标签’之后
         // >>建议将多个js文件合并成一个js文件

         // 4、输出消息的几种方式
         // js可以不需要’;‘结尾
         alert("14期威武") // 弹出对话框：包含"确认"按钮、不含'取消'按钮
         // bool类型
         var a1 = confirm("14期威武"); // 弹出对话框：包含"确认"、"取消"按钮
         // string类型
         var a2 = prompt("请输入你的账号"); // 弹出对话框：用于接收用户输入的信息
         // 转义字符
         // \n换行：一般与\t一起使用
         // \r回车：一般与\n一起使用
         // \"双引号
         // \'单引号
         console.log("14期\n\r威武"); // 在控制器输出log
         console.log("我叫\"js\""); // 我是"js"
         // console.error("输出错误"); // 显示红色
         // console.warn("输出警告"); // 显示黄色
         // 不仅可以输出信息，还可以输出标签
         document.write("14期威武"); // 在页面输出信息
         document.write("<strong>14期威武</strong>");

         // 5、js注释
         // 单行注释 - //
         // 多行注释 - /* 多行注释 */
         /**
          * 文档注释
          * @param {string} name - 姓名
          * @returns {number} - 年龄
          */

         // 6、变量
         // 1>.概念：可以变化的量
         // 2>.作用：用来存储数据
         // 3>.定义变量
         var wukong; // 定义变量
         wukong = 123; // 给变量赋值
         var wukong = "斗战胜佛"; // 定义变量同时赋值
         console.log(`孙悟空是${wukong}`) // 模版字符串
         var wendao, menghuan; // js支持一行定义多个变量（不推荐）
         // 4>.命名规范：参考标识符命名规范（数字、字母、下划线、$）
         // >>不能使用特殊符号、支持中文（不推荐使用）
         // >>不能使用‘关键字’作为标识符、可以使用‘保留关键字’作为标识符（不推荐）
         // >>严格区分大小写、变量长度不超过255个字符
         // >>推荐使用“驼峰命名”getElementById
         // 5>.全局变量
         // 1、全局变量/成员变量：任何位置都可以访问到的变量（函数外部定义的变量 + 函数内部没有var修饰的变量）
         var m1 = 10;
         function show() {
            // 2、局部变量：只有局部能够访问的变量（函数内部使用var修饰的变量）
            var m2 = 11;
            m3 = 12;
            // 3、隐式全局变量
            // b和c都是隐式全局变量
            var a = b = c = 1;
            // e和f都是隐式全局变量
            var d = 1; e = 2; f = 1;
            // 都不是隐式全局变量
            var g = 1, h = 2, i = 3;
         }
         // 6>.常量：程序运行过程中不变的量
         const PI = 3.14 // 定义一个数值常量
         const person = {
            name: "xwj",
            age: 18
         } // 定义一个对象常量
         person = {
            name: "123"
         } // 报错：不能修改
         // 可以修改对象常量的属性
         person.name = "cfj"
         console.log(person.name)
         const colors = ["red", "blue", "yellow"] // 定义一个数组常量
         colors = ["yellow", "purple"] // 报错：不能修改
         // 可以修改数组常量的元素
         colors[1] = "yellow"
         console.log(colors[1])
         // 7>.预解析
         // 原理：js的解析器在页面加载的时候，首先检查页面的语法错误，把变量声明提升起来
         // 作用：查看语法错误、变量声明提升和函数整体提升
         // 变量声明提升：只会提升变量名，不提升变量值（全局变量会提升至全局最顶层、局部变量会提升到函数内部最顶层）
         /*
         var m5;
         console.log(m5);
         m5 = 11;
         */
         console.log(m5); // undefined
         var m5 = 11;
         // 函数整体提升：只有这一种定义函数方式会整体提升（匿名函数不会整体提升）
         /*
         function getHeight() {
            console.log(m5);
         }
         getHeight();
         */
         getHeight(); // 11
         function getHeight() {
            // 函数内部也适用预解析（变量声明提升）
            // 函数内部的局部变量不会相互影响
            console.log(m5);
         }
         // // ！！！这种情况下不会“函数声明提升” - 会报错！！！
         // getMore();
         // var getMore = function () {
         //    console.log(m5);
         // }

         // 7、数据类型
         // >>简单数据类型
         // 1>.数字类型number：整数、负数、小数
         var a1 = 10;
         var a2 = 3.14;
         var a3 = -3;
         // let和var的区别 - https://www.cnblogs.com/fly_dragon/p/8669057.html
         alert(typeof(a1)); // 判断变量数据类型：可以使用()
         alert(typeof a1); // 判断变量数据类型：可以直接使用&nbsp;
         console.log(Number.MAX_VALUE); // js可以表示的最大值
         console.log(Number.MIN_VALUE); // js可以表示的最小值
         console.log(Infinity); // 无穷大：不能使用
         console.log(-Infinity); // 无穷小：不能使用
         // NaN非数值：NaN和任何数字都不相等（包括NaN本身）、undefined和任何数值计算都是NaN
         if (isNaN(Number.MAX_VALUE)) {
            console.log("是否是数字");
         }
         // 2>.字符串类型string：凡是使用""、''引起来的都是字符串
         // 字符串不可修改：给字符串重复赋值会在栈中重新开辟一个内存，原来的内存会被回收
         var a4 = '14期威武';
         var a5 = "14期威武"; // 底层有一个数据类型的转换：var a5 = new String("14期威武");、类似包装类
         // 转义字符
         // \'
         // \"
         // \n
         // \t
         console.log("\'中国\'威武"); // '中国'武威
         console.log(a5.length);  // 字符串长度
         console.log(a5.indexOf("a")); // 查询字符从前向后查询，查询到第一个就返回字符：未查到返回-1
         console.log(a5.lastIndexOf("a"));  // 查询字符从后向前查询，查询到第一个就返回字符：未查到返回-1
         console.log(a5.charAt(0)); // 查看当前索引的字符串：返回当前字符串
         console.log(a5.charCodeAt(1));  // 查找当前索引的字符：返回当前字符unicode编码（一个英文占一个字符，一个汉字占两个字符）
         console.log(a5.concat("xwj")); // 连接两个字符串（返回新字符串、a5不会被修改）
         // 数据传递的时候经常需要通过编码后再传递，接收以后还需要反编码回来
         console.log(encodeURIComponent(a5));  // 编码：将字符串做为URI组件
         console.log(decodeURIComponent(a5)); // 解码：将字符串做为URI组件
         // 字符串的截取
         var x1 = "I Love Js";
         // slice()
         alert(x1.slice(2));  // 从第2位开始截取到最后
         alert(x1.slice(2, 5)); // 从第2位开始截取到第5位[2, 5)
         alert(x1.slice(-3)); // 截取最后3个
         alert(x1.slice(5, 2)); //空字符串
         // substr
         alert(x1.substr(2, 5)); // 从第2位开始截取5位
         alert(x1.substr(-3)); // 截取最后3个
         // substring
         alert(x1.substring(2)); // 从第2位开始截取到最后
         alert(x1.substring(2, 5)); // 从第2位开始截取到第5位[2, 5)
         alert(x1.substring(-3)); // 全部截取
         // 去掉前后空格
         alert(a5.trim());
         // 替换字符串
         alert(a5.replace("today", "to")); // 把today替换成to：支持"正则表达式"
         // 字符串 -> 数组(join()相反)
         alert(a5.split(",")); // 返回数组
         // 3>.布尔类型boolean：true/false不能大写
         // 任何数据类型都可以转换成布尔类型：false、0、""、NaN、undefined、null都是false（其他对象都转换成true）
         var a6 = true;
         // 4>.undefined：变量未初始化
         var a7; // 定义变量不赋值：变量在内存中是存在的
         alert(a7); // undefined：undefined与任何数值计算都是NaN
         // >>复杂数据类型
         // 5>.null：变量没有引用、值为空
         var a8 = null; // 销毁变量：在内存中找不到这个变量（不存在）
         var a9 = ""; // 空字符串：在内存中存在
         // 6>.object：比如Array本质也是object...js中数据类型都是小写字母、理论上来讲Array并不属于js的数据类型，而是官方自定义的类（大写字母开头）
         // 7>.function
         
         // 8、运算符
         // 1>.算术运算符
         var a10 = 10;
         var a11 = "14期威武";
         // 两个数字类型相加：数字类型
         // 两个字符串类型相加：拼接字符串
         // 一个数字类型和一个字符串类型相加：字符串类型（拼接）
         alert(a10 + a11);
         // 两个数字类型相减：数字类型
         // 一个数字类型和一个数字字符串类型相减：数字类型（隐式类型转换）
         // 一个数字类型和一个非数字字符串类型相减：NaN - not a number、也是一个数字类型、不是一个数字
         // NaN与"任何数值（包括NaN）"都不相等
         alert(a10 - a11);
         // 两个数字类型相乘：数字类型
         // 一个数字类型和一个数字字符串类型相乘：数字类型
         // 一个数字类型和一个非数字字符串类型相乘：NaN
         alert(a10 * a11);
         // 两个数字类型相除：数字类型
         // 一个数字类型和一个数字字符串类型相除：数字类型
         // 一个数字类型和一个非数字字符串类型相除：NaN
         // 自然数0不能做为除数：得到Infinity无限大、也是一个数字类型
         alert(a10 / a11);
         // 取余
         alert(a10 % a11);
         // 2>.赋值运算符
         var a12;
         a12 += a11; // a12 = a12 + a11;
         a12 -= a11; // a12 = a12 - a11;
         a12 *= a11; // a12 = a12 * a11;
         a12 /= a11; // a12 = a12 / a11;
         // 3>.比较运算符：结果只有两种true、false
         // >、<、>=、<=、!=
         // 4>.逻辑运算符：结果不止只有两种true、false
         // >>&& - 两个表达式为true结果为true、只要一个表达式为false结果为false
         if (a1 > a2 && a1 < a2) {
            // 假前真后
         }
         // >>|| - 只要一个表达式为true结果为true
         if (a1 > a2 || a1 < a2) {
            // 真前假后
         }
         // >>! - 与表达式结果相反
         if (!(a1 > a2)) {
         }
         /*
         // js逻辑运算符及优先级（https://blog.csdn.net/cbjcry/article/details/84004552）
         >>总纲：真遇到||不再执行：只要一个为真就行、假遇到&&不再执行：必须全部为真
         >>a&&b -> 如果a为true则返回b、如果a为false则返回a
         >>a||b -> 如果a为true则返回a、如果a为false则返回b
         >>优先级：!逻辑非 > &&逻辑与 > ||逻辑或
         >>!逻辑非始终返回true或false
         */
         // 5>.等号运算符
         // "=="等于：判断内容是否相同，不判断数据类型
         // "==="全等于：判断内容和数据类型是否相同
         // "!="不等于：与"=="相反
         // "!=="不全等于：与"==="相反
         // 6>.逗号运算符：,
         // 7>.自增自减
         a12++; // a12需要+1、a12++先赋值再++
         ++a12; // a12需要+1、++a12先++再赋值
         a12--; // a12需要-1、a12--先赋值再--
         --a12; // a12需要-1、--a12先--再赋值

         // 9、Date对象：时间对象
         var myDate = new Date(); // 第一种方式：返回一个完整的日期时间（Mon Aug 10 2020 10:37:28 GMT+0800）
         myDate.getDate(); // 返回一个月的某一天：1 - 31
         myDate.getDay(); // 返回当前是周几：0 - 6
         myDate.getMonth(); // 返回当前月份：0 - 11
         myDate.getFullYear(); // 返回当前年份
         myDate.getHours(); // 返回当前小时
         myDate.getMinutes(); // 返回当前分钟
         myDate.getSeconds(); // 返回当前秒数：0 - 59
         myDate.getTime(); // 返回时间戳：1970年01月01日至今的毫秒数
         myDate.getTimezoneOffset(); // 返回本地时间与格林尼治标准时间(GMT)的分钟差
         // 第二种方式
         var fixDate = new Date("2020/09/17 13:45:00");

         // 10、Math对象
         var a13 = 13;
         var a14 = 14.4;
         var a15 = 15.7;
         var a16 = -3.14;
         var a17 = -3.84;
         // 返回绝对值
         Math.abs(a14); // 14.4
         // 天花板函数：向上取整
         // Math.ceil(a) >= a;、Math.ceil(a)是整数
         Math.ceil(a14);
         Math.ceil(a15);
         Math.ceil(a16);
         Math.ceil(a17);
         // 地板函数：向下取整
         // Math.floor(a) <= a;、Math.floor(a)是整数
         Math.floor(a14);
         Math.floor(a15);
         Math.floor(a16);
         Math.floor(a17);
         // 获取最大值
         Math.max(a14, a15);
         // 获取最小值
         Math.min(a14, a15);
         // 获取a14的a15次方
         // a14^a15
         Math.pow(a14, a15);
         // 获取a13的平方根
         Math.sqrt(a13)
         // 四舍五入
         Math.round(a17);
         // 获取随机数：不包括0和1
         // (0, 1)
         Math.random();
         // 返回圆周率
         Math.PI;

         // 11、数据类型转换：支持“自动类型换转”和“强制类型转换”
         // 第一种：强制类型转换
         // 1>.数字类型 -> 字符串
         // String();、toString();
         var a18 = 3.14;
         var a19 = String(a18);
         var a20 = a18 + ""; // 拼接字符串
         a20 = a18.toString();
         // 2>.字符串 -> 数字类型
         // Number();parseFloat();parseInt();
         // 数字字符串：原有数字（"3.14"-3.14、"4"-4）
         // 非数字字符串：NaN（"mylove"-NaN、"3.14Love"-NaN）
         var a21 = Number(a20);
         // 数字字符串：原有数字（"3.14"-3.14、"4"-4）
         // 数字开头的字符串：前面的数字（"3.14Love"-3.14）
         // 非数字开头的字符串：NaN（"mylove3.14"-NaN）
         var a22 = parseFloat(a18); // 返回float
         // 数字字符串：原有数字的整数部分（"3.14"-3、"4"-4、"-3.14"--3）
         // 数字开头的字符串：前面的数字的整数部分（"3.14Love"-3）
         // 非数字开头的字符串：NaN（"mylove3.14"-NaN）
         var a23 = parseInt(a18); // 返回int
         // 3>.任意类型 -> 布尔类型
         // Boolean();
         // undefined、null、0、NaN都是会转换成false
         var a24 = Boolean(a22); // true
         // 第二种：隐式类型转换
         // 1>.概述：在程序运行过程中，系统自己进行数据转换（不需要程序猿操作）

         // 12、条件语句
         // 1>.if语句：推荐使用'==='
         if (a24) {
            // 条件为true则执行该代码
         } else {
            // 条件为false则执行该代码
         }
         // 2>.if嵌套
         var name = prompt("请输入你的姓名");
         var score = prompt("请输入你的成绩");
         if (score >= 50 && score < 65) {
            alert("差");
         } else if (score >= 65 && score < 80) {
            alert("及格");
         } else if (score >= 80 && score < 95) {
            if (score === 90) {
                console.log("当前学生的名字：" + name);
            }
            alert("良");
         } else if (score > 95) {
            alert("优");
         }
         // 3>.三元运算符
         // 表达式 ? 结果1 : 结果2（表达式为true执行结果1，表达式为false执行结果2）
         // 4>.switch语言
         // “switch后面的变量：可以是number也可以是string”和“case value：可以是number也可以是string”的内容以及数据类型都要保持一致（也就是"==="）
         switch (score) {
            case 100: {

            }
                // 阻断代码执行
                break;
            case 90: {

            }
                break;
            case 80:
            case 70:
            case 60: {
               // 多个case可以共用
            }
               break;
            default: {
                // 如果表达式的值和以上的case value都不一样，执行该代码
            }
                break;
         }

         // 13、代码调试：js代码错误会暴露在运行时
         // 运行代码 -> 右键点击 -> 选择"检查代码" -> 选择"Sources" -> 打断点

         // 14、循环语句
         // 1>.while循环：条件为真则开始循环，直到条件为假结束循环
         var a25 = 25;
         while (a25 < 20) {
            alert("循环体");
            a25--;
         }
         // 2>.do...while循环：条件为真则一直循环，直到条件为假结束循环（至少循环一次）
         var a26 = 26;
         do {
            alert("循环体");
            a26--;
         } while (a26 < 26);
         // 3>.for循环
         // for(定义变量; 条件表达式; 自增自减) {}
         // let和var的区别：https://www.cnblogs.com/fly_dragon/p/8669057.html
         for (var a27 = 27; a27 > 0; a27++) {
            alert("循环体");
            a27--;
            // continue; // 跳出本次循环，开始下次循环
            // break; // 跳出循环：循环结束
            // return; // 直接返回
         }
         // 4>.循环嵌套
         for (let i = 0; i < 2; i++) {
            for (let j = 0; j < 10; j++) {
                document.write("*");
                break; // 结束内部小循环
            }
            document.write("<br>");
            break; // 结束外部大循环
         }
      //   // 5>.死循环
      //   for(;;) {

      //   }
      //   while (true) {

      //   }
      //   do {

      //   } while (true);

         // 15、数组
         // 1>.数组的定义
         var array01 = new Array(); // 使用new创建一个数组（空数组）
         array01[0] = 13; // 通过下标给数组赋值：数组元素从0开始
         array01[1] = 14;
         alert(array01); // 显示数组
         console.log(typeof(array01)); // object
         var array02 = new Array("刘备", "关羽", "张飞");
         var array03 = new Array(2); // []
         var array04 = []; // 常用
         array04[0] = "谢吴军";
         array04[1] = "中国人";
         var array05 = [1, 2, 3, 4, "中国人", "34"]; // 直接创建一个数组：数组初始化、js数组中可以有不同的数据类型
         alert(array05);
         alert(array05.length); // 数组长度
         alert(array05 instanceof Array); // 是否是数组
         alert(Array.isArray(array05)); // 是否是数组：h5新增
         alert(array05.toString()); // 数组转换成字符串
         alert(array05.values()); // 返回数组对象本身
         // 2>.数组的遍历
         // array01.length - 表示数组中元素的个数
         for (var i = 0; i < array01.length; i++) {
            // 因为数组中的元素数据类型不一样所以筛选数据最好使用===、!==
            // 通过索引获取数组的元素值
            console.log(array01[i]);
         }
         // 3>.添加元素
         array04.unshift("name"); // 队列操作：往数组最前面添加新元素、返回数组长度
         array04.push("xwj"); // 栈操作：往数组最后面添加新元素、返回数组长度
         // 4>.删除元素
         array04.shift(); // 队列操作：删除数组最前面的元素、返回最后一项
         array04.pop(); // 栈操作：删除数组最后面的元素、返回最后一项
         // 5>.数组排序
         array04.reverse(); // 翻转数组：原数组也改变，返回新数组
         array04.sort(); // 根据字符排序：功能很强大（能够对数字和字母进行排序）、只可以对第一位排序
         // 6>.数组操作
         // 1.数组连接
         var array04 = [12, 14, 18, "吴军"];
         var array05 = [3, "xwj"];
         var array06 = array04.concat(array05);
         // 2.数组截取：原数组不变
         array06 = array04.slice(3); // 从3(0开始算)开始截取
         array08 = array04.slice(1, 2); // 从1到2（包括左边不包括右边）
         array08 = array04.slice(-3); // xxx
         array08 = array04.slice(2, 1); // xxx
         // 3.数组截取：原数组改变
         array06 = array04.splice(0);
         // 4.元素查询索引
         console.log(array04.indexOf("吴军")); // 从前往后查询到第一个元素立刻返回索引
         console.log(array04.indexOf("15")); // 如果查询不到返回-1
         console.log(array04.lastIndexOf("吴军")); // 从后往前查询到第一个元素立刻返回索引
         console.log(array04.lastIndexOf("15")); // 如果查询不到返回-1
        /**
         * 数组迭代
         * @params item元素值
         * @params index元素索引
         * @params array原数组
         * 
         * @return boolean
         */
         array04.every(function (item, index, array) {
            // 对每个数组元素都执行该函数：如果都返回true则返回true，如果有一个返回false则停止遍历返回false
            // 必须返回true才会都打印
            return true; 
         }); 
        /**
         * 数组迭代
         * @params item元素值
         * @params index元素索引
         * @params array原数组
         * 
         * @return []
         */
         array04.filter(function (item, index, array) {
            // 对每个数组元素都执行该函数：返回结果为true的元素组成新数组返回
            return true;
         });
         /**
         * 数组迭代
         * @params item元素值
         * @params index元素索引
         * @params array原数组
         * 
         * @return void
         */
         array04.forEach(function (item, index, array) {
            // 遍历数组
         });
         /**
         * 数组迭代
         * @params item元素值
         * @params index元素索引
         * @params array原数组
         * 
         * @return []
         */
         var resultArray = array04.map(function (item, index, array) {
            // 对每个数组元素都执行该函数：返回函数结果组成的新数组
         });
         /**
         * 数组迭代
         * @params item元素值
         * @params index元素索引
         * @params array原数组
         * 
         * @return boolean
         */
         array04.some(function (item, index, array) {
            // 对每个数组元素都执行该函数：如果有一个返回true则返回true
         });
         // 7>.清空数组
         // 第一种方法
         array04.splice(0, array04.length);
         // 第二种方法
         array04.length = 0;
         // 第三种方法：推荐使用
         array04 = [];
         // 8>.返回一个字符串：将数组元素以“,”连接成string返回
         var array07 = [12, 13, 14, 15];
         var separatorString00 = array07.join(); // 以","连接
         var separatorString01 = array07.join(" "); // 用空字符串连接
         var separatorString02 = array07.join(""); // 以""连接
         var separatorString03 = array07.join("&"); // 用&连接
         alert(typeof(separatorString01));
         // 9>.伪数组
         // xxx
        
         // 16、函数
         // 1>.概念：完成特定功能的可以重复执行的代码块
         // 2>.格式：function 函数名(参数名1, 参数名2) { // 程序代码块：参数不需要数据类型 }
         // 3>.定义函数
         function test() {
            alert("14期威武");
            // 函数没有指定返回值的类型：因为js是弱类型语言（弱类型语言一个变量可以有多种类型）
            // 如果函数名相同：后面的函数会覆盖前面的函数（js没有方法重载）
            // 函数中有return则有返回值，没有return则没有返回值（返回值为undefined）
            return // 返回undefined
            // return后面的所有代码都不会再执行
         }
         // 4>.调用函数：函数不调用不执行
         test();
         // 5>.如果函数形参和实参个数不匹配：参数相当于局部变量
         // a.形参个数 == 实参个数：正常执行
         // b.形参个数 < 实参个数：正常执行（多余的实参不参与运算）
         // c.形参个数 > 实参个数：没有实参传入的形参默认为undefined（从而判断函数是否报错）
         // 6>.函数名和执行函数
         // >>js加载的时候只加载函数名，不加载函数体：如果想要使用内部的成员变量需要调用函数
         console.log(test); // 打印函数名：打印整个函数
         // 函数中包含函数：先执行内部test() -> 再执行外部log()
         console.log(test()); // 打印执行函数：打印函数的返回值
         // 7>.匿名函数：不支持函数类型提升
         var f1 = function demo() {
            alert("14期威武");
         }
         f1();
         var f2 = function () {
            alert("14期威武");
         }
         f2();
         // a.直接调用
         (function () {
            // 函数体
            alert("14期威武");
         })();
         // b.绑定事件
         document.onclick = function () {
            // 函数体
            alert("14期威武");
         }
         // c.定时器
         setInterval(function () {
            // 函数体
            alert("14期威武");
         }, 1000)
         // 8>.其他函数定义方式：函数也是一种数据类型function（归根结底还是object类型）
         // 不支持函数类型提升
         var f3 = new Function("alert(\"14期威武\");");
         f3();
         // 9>.递归：函数自己调用自己
         var count = 1;
         function lrShow() {
            alert("从前有座山，山上有座庙...");
            count++;
            // 递归必须有跳出条件：否则就是死循环
            if (count < 10) {
               lrShow();
            }
         }
         // 练习题：使用递归方法计算1到100的和
         // 10>.函数作为参数：回调函数（传入函数名 === 整个函数）
         function lrTest(func) {
            // 执行传入的函数：函数作为参数可以传递代码块（！！！这点是变量无法做到的！！！）
            // 代码块可以定义规则
            func();
         }
         lrTest(function () {
            
         });
         lrTest(lrShow);

         // 17、对象
         // 1>.什么是对象：对象具有特征和行为
         // 2>.面向对象和基于对象
         // >>面向对象：可以创建自定义的对象，支持封装、继承、多态（万物皆对象）
         // >>基于对象：无法创建自定义对象，不能友好的支持继承、多态
         // a、创建单个对象
         var hero = new Object();
         // 自定义属性和方法
         // 属性绑定
         // 第一种方式
         hero.money = 100;
         hero.level = 6;
         console.log(hero.money);
         // 第二种方式
         hero[height] = "180";
         hero[weight] = 18;
         console.log(hero.weight);
         // 绑定行为
         hero.attack = function () {
            
         }
         hero.attack();
         // b、创建多个对象：使用函数
         function createStudent(name) {
            // 开辟内存空间：存储新创建的对象
            // 把this设置为当前对象
            // 设置对象属性和方法
            // 返回新创建的对象
            var s1 = new Object();
            s1.name = name;
            s1.sayHi = function () {
               // this只能出现在函数中
               // 谁调用函数，this就指向谁
               console.log(this.name + "hello world")
            }
            return s1;
         }
         var student = createStudent("谢吴军")
         console.log(student.name);
         student.sayHi();
         // c.利用构造函数自定义对象：目前最终版
         // 第一步：自定义构造方法
         function Student(name) {
            this.name = name
            this.sayHi = function () {
               console.log(this.name + "hello world")
            }
            return this
         }
         var s2 = new Student("谢吴军")
         console.log(typeof(s2)) // 基于对象：无法创建自定义类型（s2底层还是object类型）
         // 3>.构造函数原理
         function Student(num) {
            this["[[PrimitiveValue]]"] = num
            return num / 1
         }

         // 18、对象字面量：{属性和方法以key&value键值对的方式存在}
         var obj1 = {
            name: "",
            "age": 18,
            sayHi: function () {
               console.log(this.name + "hello world")
            }
         }
         // >>json - javascript Object Notation（js对象表示形式、js的子集）
         // json的属性key必须使用"不能使用单引号...js字面量可以使用单引号"、对象字面量可以省略
         var json = {
            "name": "xiewujun",
            "age": 18,
            "sayHi": function () {
               console.log(this.name + "hello world")
            }
         }
         // console.log(json.length); // 报错：json没有长度
         // 遍历json
         for (var key in json) {
            // console.log(json.key); // undefined
            console.log(json[key])
         }

         // 19、数据类型的传递和存储：当你想要修改成员变量中的简单数据类型时，不要通过参数传递，需要在函数中直接修改
         // 1>.简单数据类型：值类型
         var d1 = 1;  // 入栈区：开辟空间0x100
         setFunc(d1); // 不是把地址0x100传入（传值）
         function setFunc(num) {
            num = num * 10 // 入栈区：开辟空间0x101
         }
         console.log(d1)
         // 2>.复杂数据类型：地址传递
         var d2 = new Object(); // 入堆区：开辟空间0x102
         d2.name = "xwj"
         setObject(d2) // 把地址0x102传入（传地址）
         function setObject(object) {
            object.name = "cfj" // 操作的是同一块内存空间
         }
         console.log(d2.name)
    </script>
    <!-- 3>.行内式 -->
    <div onclick="alert('我是行内式')">我是行内式</div>
</body>
</html>