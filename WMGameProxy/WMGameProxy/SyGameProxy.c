//
//  SyGameProxy.c
//  SyGameProxy
//
//  Created by 谢吴军 on 2019/6/20.
//  Copyright © 2019 zali. All rights reserved.
//

// 1.预处理指令：在编译（代码被翻译成“0和1”）之前做的操作
// 1>.概述
// a>.特点：均以"#"开头/不要“;”/编译之前就会执行
// b>.包含：文件包含、宏定义、条件编译
// c>.代码执行过程：源文件 -> 预处理 -> 汇编 -> 二进制 -> 可执行文件
// 2>.文件包含：将stdio.h文件copy到当前文件中
// a>.不用必须写在文件最上面
// b>.均以"#"开头/不要";"
// c>.<>表示先从开发工具的编译器环境中查找，如果找不到再到系统的编译环境中查找
// d>.""表示先从当前文件所在的文件夹中查找，然后再从开发工具的编译器环境中查找，如果找不到再到系统的编译环境中查找
#include <stdio.h>
// 3>.宏定义
// a>.编译预处理时将源代码中"宏名"替换成"宏内容"：不需要"="、不需要“;”
// b>.作用域：从定义那行开始一直到文件末尾
// c>.系统不会为宏分配内存
// d>.命名规则：1.全部大写|2.k+驼峰命名
// e>.不带参数的宏
#define PI 3.14
// 提前结束宏定义的作用域
//#undef PI
// f>.带参数的宏
/*
 #define - 代表定义一个宏
 GIRTH - 宏的名称
 (v1, v2) - 宏的参数/不要加数据类型
 2 * PI * v1 * v2 - 用于替换的内容
 */
/*
 g>.宏不会做任何运算/仅仅是在“编译预处理”阶段替换代码
 1.定义一个有参数的宏需要给每个参数加上一个()
 2.定义一个有参数的宏需要给结果也加上一个()
 */
#define GIRTH(v1, v2) (2 * PI * (v1) * (v2))
// h>.例子
// 用标准宏定义写一个判断系统是否是iOS12以上的版本
#define isIOS12 ([[[UIDevice currentDevice] systemVersion] floatValue] >= 12.0 ? YES : NO)
// 用标准宏定义MIN输入两个参数并返回较小一个
#define MIN(A, B) ((A) <= (B) ? (A) : (B))
// 用标准宏定义SECONDS_PER_YEAR表示1年中含有多少秒（忽略闰年）
#define SECONDS_PER_YEAR (365 * 24 * 60 * 60)UL
// 4>.条件编译
// 预编译阶段：根据条件来选择编译代码（只会将满足条件的代码编译进去/代码不会全部被编译进去）
// 条件编译不能用于判断变量（因为预处理指令替换的时候变量还没有分配空间：生命周期不一样）/一般条件编译和宏定义结合使用
// 可以减少应用程序的大小
// 一般用于调试和发布阶段进行测试
#define LOG  0
// if not define（如果没有定义LOG）
//#ifndef LOG
void conditionCompile(void) {
#if LOG == 0      // if
    printf("等于0");
#elif LOG > 0    // else if
    printf("大于0");  // 这里的代码不会被编译进去
#else                    // else
    printf("小于0"); // 这里的代码不会被编译进去
#endif        // 必须有一个明确的结束符
}

// 2.typedef：可以给一个已知的数据类型起别名
// 1>.给系统原有基本数据类型起别名
typedef int abc;
// 等于int a
abc a;
// 2>.给自定义的数据类型起别名
typedef abc MyInt;
MyInt b;
// 3>.注意：利用typedef给数据类型起别名并不会生成一个新的数据类型
// 4>.给构造类型起别名
// 第一种方式：先定义结构体类型，再给类型取别名
struct Person {
    int age;
    double height;
};
typedef struct Person SPerson;
// struct Person sp;
SPerson sp;
// 第二种方式：定义结构体类型的同时给结构体类型取别名
typedef struct Person1 {
    int age;
    double height;
} Sperson1;
Sperson1 sp1;
// 第三种方式：定义结构体类型的同时给结构体类型取别名，省略原有类型的名称
typedef struct {
    int age;
    double height;
} Sperson2;
Sperson2 sp2;
// 5>.给枚举取别名
// 第一种方式：先定义枚举类型，再给类型取别名
enum Gender {
    kGenderMale,
    kGenderFemale
};
typedef enum Gender SEX;
SEX sex = kGenderMale;
// 第二种方式：定义枚举类型的同时给结构体类型取别名
typedef enum Gender1 {
    kGenderMale1,
    kGenderFemale1
} SEX1;
SEX1 sex1;
// 第三种方式：定义枚举类型的同时给结构体类型取别名，省略原有类型的名称
typedef enum {
    kGenderMale2,
    kGenderFemale2
} SEX2;
SEX2 sex2;
// 6>.给指针取别名
char *name = "xwj";
typedef char * String;
String s1 = "xwj";

// 3.打电话
// 必须先声明、再调用
// ！！！不能写在main()底下！！！
// {}中代码就是程序段
// 其它只有在调用的时候才会执行
int call(void) {
    // 3.输出函数
    printf("打电话");
    return 0;
}
// 先写函数声明
int getMax(int m, int n);

/*
 4.C语言概述
 1>.C语言程序是由很多“程序段”组成的
 2>.C语言每条语句后面都有";"
 3>.C语言有且仅有一个“main()函数”
 4>.C语言的执行流程：编写程序->将自定义函数进行编译->目标文件/C语言函数库进行链接->可执行文件->运行
 5>.main函数
 // 一般需要将主要的函数（main函数/生命周期函数）放在最前面
 // 系统在启动程序的时候会自动调用main函数（默认只能有一个main函数）
 // main函数只能由系统调用，不能手动调用
 // argc：系统传递进来的参数个数（默认是1）
 // argv[]：系统传递进来的参数实际值（默认程序的名称）
 // 怎么添加参数：WMGameProxy -> EditScheme -> Run -> Arguments
 //int main(int argc, const char * argv[]) {
 //    // 调用系统函数
 //    // '\n'默认换行
 //    printf("Hello World!\n");
 //    // 调用自定义函数
 //    call();
 //    int result = getMax(10, 11);
 //    printf("%d", result);
 //    return 0;
 //}
 */

/*
 5.关键字
 1>.定义：被C语言赋予特殊含义的单词
 2>.特征：全部小写（严格区分大小写）、不能做为标识符、在Xcode中显示不同的颜色、一共32个
 3>.分类：流程控制关键字+数据类型关键字（unsigned、signed）
 */

/*
 6.标识符
 1>.概念：程序员自己在项目中起的名字/不能与关键字同名
 2>.命名规则（必须遵守）：
 1).定义：由字母、数字、下划线组成/严格区分大小写、不能以数字开头
 3>.命名规范（可以不遵守）：
 1).有意义的名字
 2).驼峰命名（除首单词以外其他单词首字母大写）sendMessage（也可以send_message）
 4>.常见命名：
 1).包：域名倒过来（全部小写）cn.com.itcast.javabean
 2).类/接口：首字母大写
 3).方法：驼峰法sendMessage
 4).常量：所有字母大写GET_MAX
 */

// 7.注释：不会参与编译/不会被翻译成0和1/可以用来查看代码段/可以写在任何地方
// 1>.单行注释：// 单行注释
// 2.多行注释：'/*多行注释*/
// 3.文档注释：/**文档注释 @brief*/
// */
// 项目注释
/*
 @class 哪个类
 @param 方法的参数
 @author 作者
 @date 日期
 @version 版本
 */

/*
 8.数据类型：任何变量都有数据类型（我们重点关注动态数据类型，因为程序默认是运行在内存的）
 1>.静态数据：一般以文件的形式存储在硬盘/静态数据类型 -> 动态数据类型（从磁盘加载到内存）
 2>.动态数据：动态产生的临时数据/一般存储在内存中/访问速度快/动态数据类型 -> 静态数据类型（手机拍照）
 3>.计量单位
 1TB = 1024GB
 1GB = 1024MB
 1MB = 1024KB
 1KB = 1024B
 1B(Byte) = 8bit(10101010)
 4>.基本数据类型(short/int/long/char/float/double)
 整型 - 用来存放整数 - 默认是int/short占2个字节/int占4个字节/long占8个字节/unsigned无符号整数（正数）/signed有符号整数
 浮点型 - 用来存放小数 - 默认是double/float占4个字节/double占8个字节
 字符型 - 字符型变量/'A'对/'12'错
 字符串常量 - "ADC"
 5>.构造类型：数组/结构体/枚举/共用体
 6>.指针类型
 7>.空类型void
 */
// 8>.类型说明符
// 1.说明长度：可以用来修改类型所占用的存储空间大小
int m0;   // 4个字节
//printf("m0 = %i", m0);
short int m1;  // 2个字节
//printf("m1 = %hi", m1);
long int m2;   // 8个字节
//printf("m2 = %li", m2);
long long m3; // 8个字节
//printf("m3 = %lli", m3); // 必须使用%u
// 2.说明符号位：可以用于修改符号位
signed int m4; // 取值可以是“正数/负数/零”、有符号整数（二进制最高位是符号位）、默认
unsigned int m5; // 取值可以是“正数/零”、无符号整数（二进制最高位不是符号位）
//printf("m5 = %u", m5);
// 3.不同类型的类型说明符可以混合使用
unsigned long int m6;

/*
 9.常量：不能改变的量
 1>.整型常量(整数)
 short sum = 10; int sum = 15; long sum = 100;
 signed有符号整型/unsigned无符号整型
 2>.实型常量(小数)
 float sum = 5.2f; //单精度（后面加一个f）
 double sum = 88.8; //双精度（默认情况）
 3>.字符型常量 - 普通字符/转义字符
 char sum = 'a' //''只能存放单个字符
 char sum = '13' //错误 - 13是由2个字符组成
 char name = '男' //错误写法 - 一个汉字占3个字节
 1).'\n'虽然有两个字符组成，但是还是字符型常量
 2).转义字符 - 通常以'\'开头/有实际意义/终端看不到输出结果
 4.字符串常量 - "hello world"/"a"也是字符串常量
 ps.常量在内存中有存储空间吗？？？//常量存放在“常量区”
 */

/*
 10.变量：可以改变的量
 1>.使用变量之前必须先定义变量（申请一块存储空间）
 int sum; //定义变量：分配唯一的存储空间/申请一块存储空间
 sum = 9; //给变量赋值：给存储空间存储数据/变量的第一次赋值称为初始化init/使用变量之前必须init、不然存储的都是垃圾数据
 int value,number; //连续定义：开辟两块存储空间/声明的时候就会开辟存储空间
 printf("value = %i",value); //获取value：占位符/编译期间才知道具体数值
 int number = 10; //定义同时初始化：变量第一次赋值称为init/先init才能使用
 //完全初始化：未init变量的值是随机的，实质是垃圾数据
 int value,number;
 value = number = 10;
 //部分初始化：value没有init/number = 10
 int value,number = 10;
 2>.变量类型
 1).局部变量
 a、概念：定义在{//...}内部的变量、必须先init再使用、存储在栈内存（自动释放）
 b、特点：相同作用域内不能出现同名的局部变量
 c、作用域：从"定义的那一行"开始直到“大括号/return”结束/一对"{}"可以看做一个"存储空间"
 2).全局变量
 a、概念：定义在所有函数外部的变量、定义的同时不init（系统会默认init为0）、存储在静态区（程序一启动就会分配存储空间，直到程序结束才会释放）
 b、特点：全局变量可以与局部变量同名（就近原则：局部变量会覆盖同名的全局变量）
 c、作用域：从"定义的那一行"开始直到“文件末尾”（虽然程序一启动就分配了内存）
 d、分类：外部全局变量（默认情况下所有的全局变量都是外部全局变量：可以被其它文件访问/可以定义同名的外部全局变量/多个同名的外部全局变量指向同一块存储空间）/内部全局变量（被static修饰的全局变量：只有当前文件可以访问/可以定义同名的内部全局变量/多个同名的内部全局变量如果不在同一个文件中，指向不同一块存储空间）
 3>.内存分析：
 1).内存是由字节地址组成的/字节地址是连续的
 2).内存寻址：从大到小/&变量名称：变量的详细地址/先定义的内存变量地址一定大于后定义的变量
 printf("%p\n",&number) //输出变量的详细地址：十六进制/首字节地址：小的那个/%p可以打印详细地址
 */

/*
 11.printf()函数/scanf()函数
 1>.printf()函数：输出函数
 1).格式符：%i/d（整数）、%f（浮点数）、%c（字符）、%lf（double）、%.mf（保留小数点后m位）
 2).指定位宽：%mf、%mi //m就是位宽(占据几列)/默认右对齐、左边补空格
 int number = 99;
 float value = 3.1456
 printf("%5i",number); //"补3个空格"99
 printf("%-5i",number); //99"补3个空格"
 printf("%05i",number); //宽度不够补0、超出按照实际输出/宽度够直接显示/0表示补充0、5表示占5列
 printf("%.2f",value); //保留两位小数
 printf("%.*f",n,value); //！！！保留n位小数！！！
 // 从第一位开始算起/float有效位数为7位(系统固定)/double有效位数位15位，数据超出有效位数就会出现垃圾数据
 // 怎么计算有效位数？？？从第一位开始，例如'3.1415926'从'3'开始
 float value1 = 3.1415926525
 printf("%.10f",value); /默认情况保留6位
 2>.scanf()函数：输入函数/阻塞式函数/敲击'\n'告诉系统输入完毕/ 不能加文字性说明
 int number; //定义number接收数据
 printf("请输入一个数据：")
 scanf("%i",&number); //必须加上&
 scanf("%i,%i",&num1,&num2); //什么情况下，scanf()函数自动终止？？？xxx
 实现原理：scanf()函数只要输入缓冲区中有内容（空格如果不是%c就会被忽略），就不会要求用户输入数据
 */

/*
 12.运算符
 1>.算术运算符：+|-|*|/|%  //！！！C语言中规定，参与运算的操作数类型和结果的类型肯定一致！！！
 result = 1 + 3 + 6 * 5 / 3; //result = 14/优先级：*|/ > +|-
 result = -10 % 3; //result = -1/result正负性取决于左边的操作数/！！！%只能用于整型！！！
 result = 2 % 9; //result = 2/%左边小于右边则结果为左边
 1).自动类型转换(隐式转化)/"大类型"->"小类型"可能会损失精度
 int num = 10.8; //int占4个字节/double占8个字节
 printf("number = %i\n", num); //number = 10
 2).强制类型转换(显式转化)：原表达式的值不变、强转以后结果改变
 int num = (int)10.8; //"大类型"->"小类型"可能会损失精度
 3).自动类型提升：系统会自动将"小类型"->"大类型"，不会损失精度
 double result = 10+9.9; //！！！只有相同类型的数据才可以运算：必须"自动类型提升"！！！
 2>.赋值运算符：=|+=|-=|*=|/=|%=/结合性 - 从右到左/优先级很低
 result = 5; result += 5; //result = 10
 // 复合运算符优先级 < 算术运算符优先级
 result += 5 + 3 + 5; <==> result = result + (5 + 3 + 5);
 3>.自增/自减运算符：
 int result = 5;
 int sum = result++; //先赋值、再result+1/result = 6/sum = 5
 int sum = ++result; //先result+1、再赋值/result = 6/sum = 6
 4>.sizeof运算符：一个“数据类型/常量/变量”在内存中占有字节数/“sizeof运算符”不是一个函数
 int size = sizeof(10); <==> int size = size 10; //()可以省略
 int x = 9.8; int size = sizeof(x); <==> int size = sizeof x; //()可以省略
 int size = sizeof(float); //()不能省略
 5>.逗号运算符：
 // 一般很少使用',' 获取表达式的结果/一般使用','连接多个表达式
 // ','连接多个表达式：类似于&&的含义
 if let count = array.count, let size = count + 1 {
     //整个','表达式的结果等于最后一个表达式的值
 }
 6>.关系运算符：>|<|>=|<=|==|!=/C语言规定：非0即真、0为假/“>|<|>=|<=”优先级大于“==|!=”
 a = 10, b = 5; // "="/"=="的区别
 int result = a > b; // a>b吗？
 7>.逻辑运算符：&&、||、!/C语言规定所有的数值都有真假性（非0即真）
 int sum = a && b; // 与
 int sum = a || b; // 或
 int sum = !a; // 从右至左
 int result = 4 < 5 < 6  // 错误：(5 > 4) && (5 < 6)
 1).！！！&&/||会出现“短路现象” - 只要前面的条件为假/真，后面的代码不再执行！！！
 int x = 100; int result = (x > 200) && (++x == 0);   // x = 100
 int y = 100; int result = ( y < 200) || (++y == 0);  // y = 100
 8>.三目运算符:
 int max = a > b ? a : b;
 9>.优先级
 1).“>、<、>=、<=优先级”大于“!=、==优先级”
 2).算术运算符 > 关系运算符 > 逻辑运算符/先"优先级" -> 再"结合性"
 */

/*
 13>.位运算：二进制参与运算，效率很高
 1).按位与& - 必须两个都为真才为真
 9 & 7 = 1
 00001001
 &
 00000111
 ------
 00000001
 2).按位或| - 只要一个为真则为真
 9 | 7 = 15
 00001001
 |
 00000111
 ------
 00001111
 3).按位异或^ - 相同数字为0，不同数字为1
 9 ^ 7 = 14
 00001001
 ^
 00000111
 ------
 00001110
 4).按位取反~ - 按照位置真取假，假取真
 ~9 = -10
 00001001
 ~
 ------
 11110110
 // 负数在计算机中都是补码存储
 10001001
 5>.左移<< - 乘以2的移动次幂
 9 << 1 = 18 = 9 * 2^1
 9 << 2 = 36 = 9 * 2^2
 注意：由于左移运算被移动的数的最高位会被抛弃，所以左移有可能会改变一个数的正负性
 6>.右移>> - 不移动符号位/除以2的移动次幂
 9 >> 1 = 4 = 9 / 2^1 = 4
 9 >> 2 = 2 = 9 / 2^2 = 2
 注意：负数的左移右移是补码在移动，因为负数都是以补码的形式存储在内存中
 */

/*
 14.条件语句
 1>.if语句：if语句可以嵌套/嵌套可以使用&&、||、!替代/互斥
 if(表达式1) {
     //执行代码
 }
 //必有一个执行
 if(表达式1) {
     //执行代码
 } else {
     //执行代码
 }
 if(表达式1) {
     //执行代码
 } else if (表达式2) {
     //执行代码
 } else {
     //执行代码
     //可以不需要这一句/可选类型
 }
 if(表达式1) //执行代码：只能执行第一句
 if(表达式1) {
    if(表达式2)  {
 
    } else {
        // else会匹配离它最近的一个未匹配的if
    }
 }
 2>.switch语句：C语言中'条件表达式'的返回值只支持整数（字符、枚举），不支持字符串/switch的效率理论上比if高/注意格式
 //！！！执行代码1、执行代码2、执行代码3只会执行一个！！！
 switch (条件表达式) {
 //case不能重复/不能放置变量/没有if灵活
 case 整数0: {
     //执行代码1
 }
     break; // 跳出当前case，结束switch语句
 case 整数1:
 case 整数2:
 case 整数3: {
    //执行代码2
 }
    break; // 跳出当前case，结束switch语句
 // default可以随便放置/可以放置在上面/也可以放置在最底下/default永远都是最后执行
 default: {
     //执行代码3
 }
     break; // break只能用于switch和循环结构
 }
 */

/*
 15.循环语句：反复执行某一段代码
 1>.while()语句 - 当条件满足开始执行循环体直到不满足条件停止执行/可能一次都不会执行
 // 任何数值都有真假性（非0即真）
 while(表达式) {
    //循环体
    s = s + 1; // 累加思想
 }
 2>.do-while()语句 - 先执行循环体直到不满足条件停止执行/最少执行一次循环体
 do {
    //循环体
    count++; // 计数器思想
 } while(表达式)
 3>.for()语句 - 最常使用的循环语句/推荐使用
 // ！！！循环增量为局部变量！！！
 for(初始表达式1, 初始表达式2, 初始表达式3;条件表达式;循环增量表达式1, 循环增量表达式2, 循环增量表达式3) {
    //循环体
 }
 4>.死循环 - 下面不允许写无法访问的语句/业务开发一般很少写死循环，系统开发会用到
 1).while (YES) {
    //循环体
 }
 2).for (;1;) {
    //循环体
 }
 3).RunLoop
 5>.循环嵌套
 // 循环次数 = 2 * 5
 // 外循环控制行数
 for(int i = 0;i < 2; i++) {
    // 内循环控制列数
     for(int j = 0; j < 5; j++) {
         // i = 0 -> j = 0,1,2,3,4
         // i = 1 -> j = 0,1,2,3,4
         // ！！！多层循环只能向外跳出一层！！！
         break; // 跳出循环体，终止循环
         continue; // 跳出本次循环，开始下次循环
     }
 }
 6>.循环思想：累加思想/计数思想
 7>.如果循环的增量在执行完毕循环体以后还需要使用-while/如果循环的增量在执行完毕循环体以后不再使用-for
 8>.分析内存管理：指定一块内存空间代表该项目 -> 遇到"声明属性"需要开辟内存空间 -> 遇到{}需要开辟内存空间
 */

/*
 16.数组：数组是一组有序数据的集合，数组中每个元素都具有相同的数据类型
 1>.一维数组
 // 定义一个数组长度为5的数组
 // int - 数组元素类型
 // array - 数组名
 // 5 - 数组长度
 // array[0]/array[1]/array[2]/array[3]/array[4] - 数组元素
 // 数组元素个数不能是变量
 int array[5];
 // 数组元素完全初始化
 array[5] = {1, 8, 9, 10, 18, 25};
 // 部分初始化：未初始化的元素为0
 array[5] = {1, 2, 3};
 // “定义的同时初始化”可以省略元素个数
 int array[] = {1, 8, 9, 10, 18, 25};
 // 数组访问越界
 int count = array[5];
 // 数组遍历
 int length = sizeof(数组名) / sizeof(数组名[0]);
 for (int i = 0; i < length; i++) {
    printf("%i", 数组名[i]);
 }
 2>.二维数组 - 元素是一维数组的数组称为二维数组
 // 4代表横行X轴、3代表竖行Y轴
 int array[4][3];
 // 4 - 二维数组中一维数组的个数/行数
 // 3 - 每个一维数组的元素个数/列数
 array[4][3] = {
     {1,4,6},
     {1,7,8},
     {8,5,6},
     {4,5,7}
 };
 // 赋值
 a[2][1] = 4;
 */

// 17.递归：函数自己调用自己/一般可以使用循环的地方都可以使用递归
// 慎用递归：容易栈内存溢出
// 使用场景：当不知道循环次数，但是有明确结束条件的时候可以考虑使用递归
// 必须有一个明确的结束条件：没有明确结束条件会导致死循环（无限循环）
int result = 1;
int xxx(int n) {
    // 调用函数时传入的参数我们称为实际参数（实参）
    getMax(1, 2);
    
    result = result * n;
    // 1.必须有明确的结束标志：否则会造成死循环
    if (n == 1) {
        return result;
    } else {
        // 2.自己调用自己
//        // 3.调用函数：将函数内部代码继续执行一遍
//        Log(n);
        return xxx(n-1);
    }
}
/*
 使用递归函数完成以下题目
 1.设计函数myPow计算A的N次方
 2.设计函数myFactorial求N的阶乘
 */

/*
 18.变量内存分析
 1>.变量为什么要定义类型？每种类型占用的内存空间不一样
 2>.只要定义变量，系统就会开辟一块存储空间给我们的变量存储数据（内存寻址从大到小：越先定义的变量内存地址越大）
 3>.具体操作：从内存最大位置开始，先看变量的数据类型，然后开始依次分配
 4>.变量的地址：变量的地址就是所占存储空间最小的字节地址
 5>.以"补码"形式存储/从高位->低位/一个字节存储8位
 */

// 19.函数：不使用函数的弊端/不易维护/提高代码复用性
// 一段具备特定功能的'代码块'
/*
 函数分类：
 1.标准函数：由官方或第三方库提供的函数
 2.自定义函数：由程序猿自己编写的函数
 */
/*
 定义函数：
 1.函数名称、2.函数参数、3.函数返回值
 */
// m/n称为形式参数：只有当函数被调用的时候才会分配内存
/*
 int - 返回值类型
 getMax - 函数名称
 int m, int n - 形参列表：‘形参列表中的变量（形式参数/形参）’只有当函数被调用时才会分配存储空间
 max - 返回值
 */
int getMax(int m, int n) {
    // 函数体
    /*
     C语言函数的注意事项：
     1.在函数体修改内部形参（基本数据类型）不会影响到外部实参
     2.在函数体修改内部形参（指针）会影响到外部实参
     3.实参个数必须与形参相同
     4.‘返回值’与‘返回值类型’不一致的时候系统会进行隐式转换
     5.同一个文件中函数名称不能相同（参数不一样都不行）/C语言不支持‘函数重载’
     6.C语言不支持函数嵌套定义/C语言是弱语言
     */
    // 定义局部变量
    int max = m > n ? m : n;
    // 返回数据给函数调用者
    // 结束函数
    return max;
}
// 1>.标准函数：由官方或第三方库提供的函数，可以直接使用
// 2>.自定义函数：由程序员自己编写的函数
// 2.实现函数
void Log(int m) {
    printf("hello world");
}
// 有参有返回值/有参无返回值/无参有返回值/无参无返回值
// 形参&实参

/*
 20.字符串 - 由字符组成的串""/可以使用数组来保存字符串/%s
 1>.“字符串”和“普通字符数组”的区别：字符串以“\0”结尾，字符串比字符数组多一个元素“\0”
 char str[] = "xwj";
 printf("---%s---", str);
 2>.了解的方法：#include <ctype.h>
 int isalpha(int c); //判断单个字符是否是字母
 int isnumber(int c); //判断单个字符是否是表示数字
 int isupper(int c); //判断单个字符是否是大写字母
 int islower(int c); //判断单个字符是否是小写字母
 int toupper(int c); //将单个字符转换为大写字母
 int tolower(int c); //将单个字符转换为小写字母
 3>.掌握的方法：#include<string.h>
 //sizeof(const char *s)占用字节大小
 size_t strlen(const char *s); //！！！返回字符串的有效字符个数：与sizeof()区别？！！！
 char *strcat(char *s1,const char *s2); //！！！将s2的内容拼接到s1后面形成新的字符串s1！！！
 //返回子串在s1中首次出现位置的第一个字符的地址
 char *strstr(const char *s1, const char *s2); //在字符串s1中，寻找子串s2首次出现的位置
 //s1必须有足够大的空间，如果数组越界，可能导致未知的错误
 char *strcpy(char *s1,const char *s2); //将字符串s2拷贝到字符数组s1，返回s1
 char *strchr(const char *s,char c); //查找字符串s中首次出现字符c的位置，不存在c,返回NULL
 //s1 > s2 -> 返回正数，s1 < s2 -> 返回负数，s1 == s2 -> 返回0
 int strcmp(const char* s1,const char* s2); //比较两个字符串的大小关系
 char *strrchr(char *str, char c); //在串中查找指定字符的最后一个出现，失败返回NULL
 4>.字符串数组就是二维数组
 char names[5][20] = {
    "xwj",
    "cfj",
    "xj"
 }
 */

/*
 21.C语言内存管理：sizeof()是一个运算符，用来计算变量或数据类型的大小
 1>.静态内存分配：在编译阶段分配的内存/分配在数据段、只读数据段、栈区/由编译器自动申请和释放
 2>.动态内存分配：在运行阶段分配的内存/分配在堆区/由程序员手动申请和释放/将这个空间的首地址返回给指针变量p
 // 动态申请内存
 char *p = (char *)malloc(100*sizeof (char));
 // 动态释放内存
 free(p);
 3>.注意：防止提前释放、防止内存泄露、防止重复释放
 4>.C语言的内存管理需要我们手动申请、手动释放
 1).手动申请内存，使用以后需要手动释放，如果不释放会造成内存泄露
 2).不能多次释放，如果多次释放，则会崩溃
 3).不能提前释放，如果提前释放再使用，也会崩溃
 */
// 基本数据类型做为函数参数是值传递 - 函数内部修改形参的值不会影响外面实参的值
void changeInt(int value) {
    value = 55;
}
// 数组做为函数参数是地址传递 - 函数内部修改形参的值会影响外面实参的值
void changeArray(int values[]) {
    values[1] = 88;
}
// 这样的话就可以在函数内部修改外部实参的值
void changeAddress(int *p) {
    
}
/*
 问题：如果项目比较复杂，需要上百号人一起分工完成，就很容易出现问题：比如我们开辟了一块内存空间，存放了一块很有用的数据。
 但是，这个数据不只有我在这一块代码里用，甚至有多个人，在程序的多个地方使用。这样造成的结果：就算我使用完成这块内存，
 我也不能去释放他，因为我不能确定，别人在别的地方是否还需要使用这块内存。内存泄露在所难免
 */

// 22.指针
void showPointer(void) {
    // 1.如何定义指针变量
    // 数据类型：说明将来指针变量能够保存什么类型的变量的地址（指针变量是什么类型就只能保存什么类型变量的地址）
    // *：没有任何特殊含义，仅仅是为了表示这是一个指针变量
    // 变量名称：用于区分不同的变量
    // a>.格式：数据类型 * 变量名称
    int *p; // 指针变量用于存放变量地址（只能存放地址）
    int num = 10;
    p = &num; // 将变量num地址存放在指针p里面（&num表示num的地址 - &表示取地址符）
    // *p == num
    num = 15; // 直接改变num的值
    *p = 20; // *p表示p指向的那一块存储空间所对应的变量（间接改变num的值）
    
    // 2.指针的注意点
    // a.指针只能保存地址（地址就是唯一标识一块内存的索引）
    // b.同一个变量可以有多个指针指向它
    // c.指针的指向可以修改
    // d.不要访问野指针（没有赋值的指针称为野指针）
    // e.指针类型是什么类型就只能指向什么类型的数据
    
    /*
     // 3>.面试题：交换两个变量
     // 1.传值：无法实现交换
     void Swap1(int a,int b){
         printf("swap1：%p,%p\n",&a,&b);
         int t;
         t = a;
         a = b;
         b = t;
     }
     // 2.传地址：交换指针指向，无法实现交换
     void Swap2(int *c,int *d){
         printf("swap2：%p,%p\n",c,d);
         int *t;
         t = c;
         c = d;
         d = t;
     }
     // 3.传地址：交换指针指向变量的值，可以实现交换
     void Swap3(int *e,int *f) {
         printf("swap3：%p,%p\n",e,f);
         int t;
         t = *e;
         *e = *f;
         *f = t;
     }
     Swap1(a, b);
     Swap2(&c, &d);
     Swap3(&e, &f);
     */
    
    // 4>.指针大小：固定4个字节（因为地址在内存里都是以整型的方式分配的）
    // p1和q1都是4个字节
    char *p1;
    int *q1;
    
    // 5>.指针作为函数参数
    
    // 6>.指针作为函数返回值
    
    // 7>.指向字符串的指针
    char * p2 = "1234567";
    
    // 8>.指针++
    int *p3 = NULL;
    int a = 5;
    p3 = &a;
    // 执行p++操作时，指针向后移动了p指向的变量的基类型的大小个字节数
    // 指针的移动：必须赋值地址才可以实现指针的移动，不可以赋值指针所指的内容
    p3++;
    
    // 8>.数组和指针
    // 指针数组：元素为指针的数组
    int *p4[10]; // 这是一个数组，10个元素，每个元素都是个指向整型的指针
    // 数组指针：指向数组的指针
    int (*p5)[10]; // 这是一个指针，指向10个int元素的数组
    // 二级指针：指向指针的指针
    int * * p6; // 这是一个指针，指向指针
    // 函数指针：指向函数的指针
    int (*p7)(int a); // 这是一个指针，指向一个函数
    // 返回值类型 ( * 指针变量名) (形参列表);
}

// 23.其它类型
/*
 // 结构体
 1>.结构体：变量的集合
 struct data {
     int a;
     char b;
     short c;
 };
 struct data d = {1, 'a', 2};
 d.a = 1;
 d.b = 'a';
 d.c = 2;
 2>.给结构体起别名：wm_data
 typedef struct data {
     int a;
     char b;
     short c;
 }wm_data;
 wm_data d1;
 3>.结构体指针
 xxx
 // 共用体
 1>.共用体：使几个不同变量共同占用一段内存的结构
 union date {
     int a;
     char b;
     short c;
 };
 2>.内存大小：共用体变量所占内存长度等于最长成员的长度
 3>.特点
 共用体是同一段内存存储相同或不同类型的成员，同一时刻只存放一种
 共用体变量中起作用的成员是最后一次存放的成员
 */
