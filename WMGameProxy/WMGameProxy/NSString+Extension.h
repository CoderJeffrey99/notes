//
//  NSString+Extension.h
//  WMGameProxy
//
//  Created by 谢吴军 on 2019/10/23.
//  Copyright © 2019 zali. All rights reserved.
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN
/*
 1.类别Category：非常灵活的类扩展机制（也称分类）/子类是进行类扩展的另一种常用方法
 // 1.作用
 1>.可以在不获悉和不改变原来代码的情况下往类里面添加新的方法
 2>.将类的实现分散到多个不同文件或多个不同框架中
 // 2.特点
 1>.一旦使用类别给已有的类增补方法，那么这个类的对象就可以使用该方法
 2>.不修改原有类的基础上给“已有的类/系统原生类”增加方法：组件化基础
 3>.可以对类的方法进行分类管理：将类的实现分散到多个不同的文件和框架中
 // 3>.注意点
 1>.类别中不能添加成员变量（在分类property只能生成setter/getter方法的声明，不会生成setter/getter方法的实现和私有的成员变量：编译没事，引用变量会报错）
 2>.使用类别必须导入类别头文件
 3>.父类类别中的方法子类也可以使用（可以在分类中访问原有类中.h中的属性、分类和原有类中的方法同名会优先调用分类中的方法）
 4>.如果多个分类和原有类都有同名方法，则调用该方法的顺序由编译器决定（会执行最后一个参与编译的分类中的方法）
 // 方法调用的顺序：分类 -> 本类 -> 父类
 */
@interface NSString (Extension)
// 可以扩展原有类的方法
// 可以重写原有类的方法
// 不能添加属性（实例变量）：有方法可以添加（高级部分）
-(void)validateEmail;

// 因为不会生成 _name/不用属性修饰符
@property NSString *name;
/*
 1.怎么保证自己的类一定能调用到自己写的方法？（不知道有没有人会写一个分类，里面有和自己的类方法名字一模一样）
 Category并不会覆盖主类的同名方法，只是Category的方法排在主类方法的前面，OC的消息发送机制是根据方法名在method_list中查找方法，找到第一个名字匹配的方法之后就不继续往下找了，每次调用的都是method_list中最前面的同名方法
 2.简述一下什么时候使用继承？什么时候使用类别？
 在Objective-C语言中，一个类继承另一个类就等于继承了另一个类的所有属性和方法，也就是说既可以扩充自己的属性也可以扩充方法，类别是在不改变原有类的基础上进行方法扩充，只能扩充方法。因此，根据开发需求，如果某个类需要扩充属性或者重写另一个类的某些方法使用继承，如果某个类只需要扩充方法使用类别
 3.类别的局限性
 1>.无法向一个类中添加新的实例变量
 2>.当类别中的方法与原始类方法名称冲突时，优先使用类别中的方法，如果多个类别中名称冲突时，优先使用最后一个参与编译类别里面的方法
 3>.分类里面的property只能生成setter和getter的声明，并不能生成setter和getter的实现
 4.类别和类扩展的区别
 类别可以在不获悉和不改变原来代码的情况下往里面添加新的方法（添加的方法可以被子类方法、不能添加属性：属性仅仅是声明，没有实现）、类别有名称
 类扩展可以添加属性、类扩展添加方法必须实现（自身只能声明方法不能实现方法）、类扩展只能在当前类中添加方法、类扩展没有名称（类扩展就是私有的类别）
 */

@end

NS_ASSUME_NONNULL_END
